# 重入锁和读写锁

在J·U·C包中提供大量的并发编程相关的辅助工具，比如阻塞队列，线程池，锁，并发集合等。JUC中有一个Lock接口，它的作用和synchronized的相似，都是为了保证线程安全提供的解决方案。Lock定义了抢占锁和释放锁相关操作。

- lock()
- tryLock()
- unlock()
- ...

Lock是一个接口，它只是提供了抢占锁和释放锁的抽象方法，在JUC中提供了以下具体实现类

- ReentrantLock，重入锁，属于排它锁类型，功能和synchronized相似
- ReentrantReadWriteLock，可重入读写锁，该类维护了两个锁，一个是ReadLock，一个是WriteLock，它们分别实现了Lock接口
- StampedLock，java8引进的新的锁机制，它是ReentrantReadWriteLock的改进版本。



## ReentrantLock

ReentrantLock是一个可以支持重入的排他锁。重入指的是一个线程获得了，后续该线程再去抢占相同的锁资源不需要再竞争锁。排他锁，就是同一时刻只允许一个线程获得锁资源。

### ReentrantLock的使用

```java
public class ReentrantLockDemo {
    static Lock lock = new ReentrantLock();

    private int count = 0;

    public void incr() {
        lock.lock(); // 加锁
        try {
            count++;
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReentrantLockDemo reentrantLock = new ReentrantLockDemo();
        Thread[] threads = new Thread[2];
        for (int i = 0;i<2;i++) {
            threads[i] = new Thread(() ->{
                for (int k = 0; k<100000;k++) {
                    reentrantLock.incr();
                }
            });
            threads[i].start();
        }
        threads[0].join();
        threads[1].join();
        System.out.println(reentrantLock.count); // 输出200000
    }
}
```

上述demo使用了ReentrantLock的lock()和unlock()方法，并针对count++的非原子操作进行加锁，保证了在多线程的情况下，线程的 安全性。



### ReentrantLock的猜想

我们在明确一下，ReentrantLock是一个可重入的排他锁，如果要让我们去设计，需要考虑哪些问题呢？

> - 锁的互斥，必须有一个共享变量去记录锁有没有被抢占
> - 可重入，需要一个记录当前是哪个线程占有锁的变量
> - 没有抢到锁的线程，需要阻塞，获得锁的线程在释放线程的时候要唤醒阻塞的线程
> - 要有一个地方去存储这些阻塞的线程



