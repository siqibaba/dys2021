# synchronized

线程能很大提升程序的工作效率，但是使用不合理就会带来很多不可控的问题，比如线程安全问题。

什么是线程安全问题呢？当多个线程访问某个方法时，这个方法无法按照我们预期来执行，我们就认为这是线程不安全的。

那么导致线程不安全原因是什么呢？

- 原子性
- 有序性
- 可见性

## 原子性

什么是原子性？原子性指的是不可分隔，程序在执行时，不可中断。

我们看下面的代码

```java
public class AtomicDemo {
    volatile int i = 0;

    public void incr(){
        i++;
    }

    public static void main(String[] args) throws InterruptedException {
        AtomicDemo atomicDemo = new AtomicDemo();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i<1000; i++) {
                atomicDemo.incr();
            }
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i<1000; i++) {
                atomicDemo.incr();
            }
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("result：i=" + atomicDemo.i);
    }
}
```

运行结果：

```tex
result：i=1835
```

可以看到，预期出现的i值应是2000，但是并没有出现，导致这个问题的原因是什么呢？就是原子性，i++的操作并不是原子的，我们来看看i++，到底经历了哪些操作。

通过`javap -v AtomicDemo.class`，查看字节码

```tex
public void incr();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #2                  // Field i:I
         5: iconst_1
         6: iadd
         7: putfield      #2                  // Field i:I
        10: return
      LineNumberTable:
        line 7: 0
        line 8: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/example/threadstudy/current/syn/AtomicDemo;
```

可以看到i++，经历了4步操作：

> 第一步获取属性值：getfield
>
> 第二步将常量压入栈中：iconst_1
>
> 第三步在寄存器进行+1操作：iadd
>
> 第四步将结果保存在内存中：putfield

执行一个i++需要四步，也就是i++的操作不是原子性的。

既然我们已经知道了i++不是原子性的，那么什么样的情况会带来原子性问题呢？

- CPU时间片切换
- 多线程并行执行

线程的时间片切换导致原子性问题

![image-20211122075229906](..\..\..\images\image-20211122075229906.png)



多线程并行执行导致原子性问题

![image-20211122075639505](..\..\..\images\image-20211122075639505.png)

