线程

​	现在大家一直高并发，那么什么是并发？并发的本质又是什么呢？

## 并发与并行

​	什么是并发？并发是指在某一**时间间隔**能处理完多少线程任务。比如：有100个线程同时发起了任务请求，由于电脑cpu核数的限制，不可能同时处理这个100个线程任务，但是CPU会有时间片切换，假如在1s内，将这100个线程任务处理完成，那么我们就可以说，并发量达到了100。

​	说到了并发，我们就不得不说说并行，那么什么是并行呢？并行是在同一**时刻**，可以同时运行的线程任务，受到CPU核数限制，比如4核的CPU，那么同一时刻，他只能运行4个线程任务。

​	好好体会一下，这两者的区别，一个是时间间隔内，一个是同一时刻。再举个例子，现在有100个小笼包，你能在1s内将这100个小笼包吃完，那么就说明你有100 的并发能力，但是在吃这个方式上，比如你能一口4个，那么说明你的并行数是4，一口8个，说明你的并行说是8。

## 什么是线程

​	上面我们说到并发与并行，一直在提一个词**线程**，从上面我们对并发和并行的描述，我们不难看出，线程，是计算机的最小运行单元，也就是真正去干活的人。官方给出的定义是，线程是操作系统能够运行和调度的最小单元。在一个进程中可以创建多个线程，这些线程可以并行执行多个任务，并行执行的线程数量是由CPU决定的。

## 线程的价值

​	计算机可以同时运行多个线程，那么线程对于我们开发来说，到底有什么价值呢？举个例子，以前我们有一个方法，用户注册，注册时需要两个步骤，一个是保存用户信息，二是发送邮件通知。如下图所示

![image-20211117074523585](..\..\..\images\image-20211117074523585.png)

那么我们处理完这个方法，就需要5s的时间，但是，我们要充分发挥资本家的嘴脸，一个线程在这干活，计算机还有能里处理其他线程能，那么正在创建一个线程，一起处理这个方法，但是你多个线程干活，你不能打乱本有的干活方式，所以，保存完用户信息，就可以返回去了，再创建一个线程，让他去发送邮件，我们不用管了。因为不管邮件是否发送成功，我们用户都注册成功了。经过改良就变成了下图的方式。

![image-20211117075023484](..\..\..\images\image-20211117075023484.png)

## 线程的创建

​	说完线程的价值，那么线程在我们java程序中是如何创建的呢？java创建线程，有三种方式

### 实现Runnable接口创建线程

Runnable 是声明一个线程的接口

```java
public class RunnableThreadDemo implements Runnable{

    @Override
    public void run() {
        System.out.println("RunnableThreadDemo#run");
    }

    public static void main(String[] args) {
        new Thread(new RunnableThreadDemo()).start();
    }
}
```

### 继承Thread类

```java
public class ThreadDemo extends Thread{

    @Override
    public void run() {
        System.out.println("ThreadDemo#run");
    }

    public static void main(String[] args) {
        new ThreadDemo().start();
    }
    
}
```

### 实现Callable接口并带返回值

```java
public class CallableThreadDemo implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "CallableThreadDemo#call";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableThreadDemo callableThreadDemo = new CallableThreadDemo();
        FutureTask<String> futureTask = new FutureTask<>(callableThreadDemo);
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
    }
}
```

Runnable和继承Thread实现的方式不同，但是本质是一样的，都是接口Runnable的实现，但是当一个实现线程的类继承了其他类，就无法通过继承Thread类来实现线程了，只能通过实现Runnbale来实现。

![image-20211119081944442](..\..\..\images\image-20211119081944442.png)

Callable接口提供了一个返回值，定义了FutureTask，来表示获取未来结果的任务，并使用Thread线程来执行，最后可以通过futureTask.get()获取结果

## 线程的启动

​	我们已经知道了线程的实现方式，那么线程是如何启动的呢？从上面的案例我们已经能够知道，线程的启动并不是直接去调用他的run方法，而是调用start()，如果直接调用run()，就不涉及到线程一说了，和一个类直接调用执行方法没有任何区别。

## 线程的停止

